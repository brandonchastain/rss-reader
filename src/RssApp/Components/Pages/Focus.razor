@page "/focus"
@rendermode InteractiveServer
@attribute [StreamRendering]
@inject ILogger<Timeline> logger
@inject IFeedClient feedClient
@inject IJSRuntime jsRuntime
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Sve.Blazor.InfiniteScroll.Components
@inject ILogger<Posts> logger
@inject IJSRuntime jsRuntime

<PageTitle>Focused Feed</PageTitle>

<div class="" style="position: relative; z-index: 10000;">
    <button @onclick="() => PrevPage()">Prev</button>
    <button @onclick="() => NextPage()">Next</button>
</div>

<div id="focus-post-table">
@if (Posts != null && Posts.Count > 0) {
    var post = Posts.First();
    <div id="post-header-img">
    @{
        var thumbnailUrl = post.GetThumbnailUrl();
        if (!String.IsNullOrWhiteSpace(thumbnailUrl))
        {
            <img src="@post.GetThumbnailUrl()" alt="Thumbnail" />
        }
    }
    </div>

    <div id ="focus-post-spacer"></div>
    <div id="focus-post-content">
        <div id="focus-post-content-container">
        <p>
            <a tooltip="@post.ParsedDate?.ToString("f")" href="@this.GetEffectiveHref(post)" target="_blank" @onclick:stopPropagation="true">@post.Title</a><br/>
        </p>
        <p>
            @if (!String.IsNullOrWhiteSpace(post.CommentsHref))
            {
                <a href="@post.CommentsHref">[Go to comments]</a>
            }
        </p>
        <p>
            @this.GetRootDomain(post.Href)<br/>
        </p>
        <p>
            @(post.FeedTags.Any() ? $"[{string.Join(",", post.FeedTags)}]" : "")
        </p>
        <p>
            Published on @post.ParsedDate?.ToString("f")
        </p>
        <p>
            @((MarkupString)HtmlSanitizer.Sanitize(post.Content))
        </p>
        <p>
            <a href="/posts?feedUrl=@System.Net.WebUtility.UrlEncode(post.FeedUrl)" onclick="event.stopPropagation()">View all posts from this feed</a><br/>
        </p>
        </div>
    </div>
}
</div>

@code {
    public RssUser CurrentUser { get; set; }
    public int Page { get; set; } = 0;
    public List<NewsFeedItem> Posts { get; set; } = new List<NewsFeedItem>();
    private bool initialized = false;
    private int loadedPage = -1;

    private async Task PrevPage()
    {
        if (!initialized)
        {
            return;
        }

        if (Page > 0)
        {
            Page -= 1;
        }

        await this.RefreshPosts((this.feedClient.IsFilterUnread, this.feedClient.FilterTag));
    }
    private async Task NextPage()
    {
        if (!initialized)
        {
            return;
        }

        Page += 1;

        await this.RefreshPosts((this.feedClient.IsFilterUnread, this.feedClient.FilterTag));
    }

    private async Task RefreshPosts((bool isFilterUnread, string filterTag) filters)
    {
        if (filters.isFilterUnread != this.feedClient.IsFilterUnread
            || filters.filterTag != this.feedClient.FilterTag)
        {
            Posts = new List<NewsFeedItem>();
            Page = 0;
            this.feedClient.IsFilterUnread = filters.isFilterUnread;
            this.feedClient.FilterTag = filters.filterTag;
        }
        
        var newPageRes = await this.feedClient.GetTimelineAsync(Page, pageSize: 1);
        Posts = newPageRes.ToList();
        Posts = Posts.Distinct().ToList();
        this.loadedPage = Page;
        this.StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (CurrentUser == null)
        {
            var username = await this.GetUsernameAsync();
            this.CurrentUser = await this.feedClient.RegisterUserAsync(username);
            Posts = (await this.feedClient.GetTimelineAsync(Page, pageSize: 1)).ToList();
            this.initialized = true;
            this.StateHasChanged();
        }
    }

    private async Task<string> GetUsernameAsync()
    {
        return await jsRuntime.InvokeAsync<string>("getUsername");
    }

    private string GetRootDomain(string url)
    {
        return new Uri(url).Authority;
    }

    private string GetEffectiveHref(NewsFeedItem post)
    {
        if (post.IsPaywalled)
        {
            return "https://archive.is/" + post.Href;
        }

        return post.Href;
    }
}