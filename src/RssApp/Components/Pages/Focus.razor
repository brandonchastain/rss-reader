@page "/focus"
@rendermode InteractiveServer
@attribute [StreamRendering]
@inject ILogger<Timeline> logger
@inject IFeedClient feedClient
@inject IJSRuntime jsRuntime
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Sve.Blazor.InfiniteScroll.Components
@inject ILogger<Posts> logger
@inject IJSRuntime jsRuntime

<PageTitle>Focused Feed</PageTitle>

@if (isLoading)
{
    <div class="loading-overlay">
        <div class="spinner"></div>
    </div>
}

<div class="" style="position: relative;">
    <button class="focus-nav-button focus-nav-prev" @onclick="() => PrevPost()">←</button>
    <button class="focus-nav-button focus-nav-next" @onclick="() => NextPost()">→</button>
</div>

<div id="focus-post-table">
@if (CurrentPost != null)
{
    var post = CurrentPost;

    <div>
    @{
        var thumbnailUrl = post.GetThumbnailUrl();
        if (!String.IsNullOrWhiteSpace(thumbnailUrl))
        {
            <img src="@post.GetThumbnailUrl()" alt="Thumbnail" />
        }
    }
    </div>

    @* <div id ="focus-post-spacer"></div> *@
    <div id="focus-post-content">
        <div id="focus-post-content-container">
        <p>
            <a tooltip="@post.ParsedDate?.ToString("f")" href="@this.GetEffectiveHref(post)" target="_blank" @onclick:stopPropagation="true">@post.Title</a><br/>
        </p>
        <p>
            @if (!String.IsNullOrWhiteSpace(post.CommentsHref))
            {
                <a href="@post.CommentsHref">[Go to comments]</a>
            }
        </p>
        <p>
            @this.GetRootDomain(post.Href)<br/>
        </p>
        <p>
            @(post.FeedTags.Any() ? $"[{string.Join(",", post.FeedTags)}]" : "")
        </p>
        <p>
            Published on @post.ParsedDate?.ToString("f")
        </p>
        <p>
            @((MarkupString)HtmlSanitizer.Sanitize(post.Content))
        </p>
        <p>
            <a href="/posts?feedUrl=@System.Net.WebUtility.UrlEncode(post.FeedUrl)" onclick="event.stopPropagation()">View all posts from this feed</a><br/>
        </p>
        </div>
    </div>
}
</div>

@code {
    public RssUser CurrentUser { get; set; }
    public int Page { get; set; } = 0;

    public int PostIndex { get; set; } = 0;
    public NewsFeedItem CurrentPost { get; set; } = null;
    public List<NewsFeedItem> Posts { get; set; } = new List<NewsFeedItem>();
    private bool initialized = false;
    private int loadedPage = -1;
    private bool isLoading = false;

    private double touchStartX;
    private double touchStartY;
    private string swipeClass = "";
    private const int SWIPE_THRESHOLD = 50;
    private bool isHorizontalSwipe = false;

    private void HandleTouchStart(TouchEventArgs e)
    {
        touchStartX = e.Touches[0].ClientX;
        touchStartY = e.Touches[0].ClientY;
        isHorizontalSwipe = false;
    }

    private void HandleTouchMove(TouchEventArgs e)
    {
        if (touchStartX == 0) return;
        
        var deltaX = e.Touches[0].ClientX - touchStartX;
        var deltaY = e.Touches[0].ClientY - touchStartY;

        if (!isHorizontalSwipe && Math.Abs(deltaX) > Math.Abs(deltaY) && Math.Abs(deltaX) > 10)
        {
            isHorizontalSwipe = true;
        }

        if (isHorizontalSwipe && Math.Abs(deltaX) > SWIPE_THRESHOLD)
        {
            swipeClass = deltaX > 0 ? "swipe-right" : "swipe-left";
            StateHasChanged();
        }
    }

    private async Task HandleTouchEnd(TouchEventArgs e)
    {
        if (string.IsNullOrEmpty(swipeClass)) return;

        if (swipeClass == "swipe-right" && Page > 0)
        {
            await PrevPage();
        }
        else if (swipeClass == "swipe-left")
        {
            await NextPage();
        }

        swipeClass = "";
        touchStartX = 0;
        StateHasChanged();
    }

    private async Task PrevPost()
    {
        this.PostIndex -= 1;
        if (this.PostIndex < 0)
        {
            this.PostIndex = this.Posts.Count - 1;
            await PrevPage();
        }

        this.CurrentPost = this.Posts[this.PostIndex];
        this.StateHasChanged();
    }

    private async Task NextPost()
    {
        this.PostIndex += 1;
        if (this.PostIndex >= this.Posts.Count)
        {
            this.PostIndex = 0;
            await NextPage();
        }

        this.CurrentPost = this.Posts[this.PostIndex];
        this.StateHasChanged();
    }

    private async Task PrevPage()
    {
        if (!initialized)
        {
            return;
        }

        if (Page > 0)
        {
            Page -= 1;
        }

        await this.RefreshPosts((this.feedClient.IsFilterUnread, this.feedClient.FilterTag));
    }

    private async Task NextPage()
    {
        if (!initialized)
        {
            return;
        }

        Page += 1;
        await this.RefreshPosts((this.feedClient.IsFilterUnread, this.feedClient.FilterTag));
    }

    private async Task RefreshPosts((bool isFilterUnread, string filterTag) filters)
    {
        isLoading = true;
        this.StateHasChanged();

        if (filters.isFilterUnread != this.feedClient.IsFilterUnread
            || filters.filterTag != this.feedClient.FilterTag)
        {
            Posts = new List<NewsFeedItem>();
            Page = 0;
            PostIndex = 0;
            this.feedClient.IsFilterUnread = filters.isFilterUnread;
            this.feedClient.FilterTag = filters.filterTag;
        }
        
        var newPageRes = await this.feedClient.GetTimelineAsync(Page, pageSize: 20);
        Posts.AddRange(newPageRes);
        Posts = Posts.Distinct().ToList();
        this.loadedPage = Page;
        this.CurrentPost = Posts[PostIndex];
        isLoading = false;
        this.StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (CurrentUser == null)
        {
            var username = await this.GetUsernameAsync();
            this.CurrentUser = await this.feedClient.RegisterUserAsync(username);
            await RefreshPosts((this.feedClient.IsFilterUnread, this.feedClient.FilterTag));
            this.initialized = true;
            this.StateHasChanged();
        }
    }

    private async Task<string> GetUsernameAsync()
    {
        return await jsRuntime.InvokeAsync<string>("getUsername");
    }

    private string GetRootDomain(string url)
    {
        return new Uri(url).Authority;
    }

    private string GetEffectiveHref(NewsFeedItem post)
    {
        if (post.IsPaywalled)
        {
            return "https://archive.is/" + post.Href;
        }

        return post.Href;
    }
}