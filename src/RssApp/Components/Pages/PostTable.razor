@inherits Base
@rendermode InteractiveServer
@attribute [StreamRendering]
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Sve.Blazor.InfiniteScroll.Components
@using global::RssApp.RssClient
@inject ILogger<Posts> logger
@inject IJSRuntime jsRuntime
@inject FeedRefresher feedRefresher

<AuthorizeView>
@if (Posts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    if (ShowToolbar)
    {
        <div>
            <p>Last refreshed on @feedRefresher.LastCacheReloadTime</p>
        </div>
        <div class="toolbar">
            <button class="btn-link" @onclick="() => ToggleUnreadFilterAsync()">@(this.IsFilterUnread ? "[all]" : "[unread]")</button>
            <button class="btn-link" @onclick="() => ToggleSavedFilterAsync()">@(this.IsFilterSaved ? "[all]" : "[saved]")</button>
            @foreach (var tag in this.userTags)
            {
                <button class="btn-link" style="@(this.filterTag == tag ? "color: pink" : "")" @onclick="() => FilterForTag(tag)">[@tag]</button>
            }

            
            <button class="btn-link" @onclick="() => feedRefresher.RefreshAsync()">[refresh]</button>

        </div>
    }
    <div id="post-table" class="table">
        <InfiniteScroll ObserverTargetId="observerTarget" ObservableTargetReached="(e) => Next()">
            @foreach (var post in Posts)
            {
                <div class="row @(post.IsRead ? "post-read" : "post-unread")" @onclick="() => PreviewPost(post)" hidden=@(ShouldPostBeHidden(post))>
                    <div class="col thumbnail">
                        @{
                            var thumbnailUrl = post.GetThumbnailUrl();
                            if (!String.IsNullOrWhiteSpace(thumbnailUrl))
                            {
                                <img src="@post.GetThumbnailUrl()" alt="Thumbnail" class="thumbnail" />
                            }
                        }
                    </div>
                    <div class="col">
                        <p class="post-title">
                            <a tooltip="@post.ParsedDate?.ToString("f")" href="@this.GetEffectiveHref(post)" target="_blank" @onclick:stopPropagation="true" @onclick="() => MarkAsRead(post, true)">@post.Title</a><br/>
                            @if (!String.IsNullOrWhiteSpace(post.CommentsHref))
                            {
                                <a href="@post.CommentsHref">[comments]</a>
                            }
                            <button class="link" @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="() => MarkAsRead(post)">[mark @(!post.IsRead ? "read" : "unread")]</button>
                            <button class="link" @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="async () => await SavePost(post)">[@(!post.IsSaved ? "save" : "unsave")]</button>
                            @this.GetRootDomain(post.Href)<br/>
                            @(post.FeedTags.Any() ? $"[{string.Join(",", post.FeedTags)}]" : "")
                        </p>
                    </div>
                </div>
                <div class="postContent" hidden=@(!post.IsBeingPreviewed)>
                    @if (post != null)
                    {
                        <div class="">
                            <p>
                                Published on @post.ParsedDate?.ToString("f")
                            </p>
                            <p>
                                @((MarkupString)HtmlSanitizer.Sanitize(post.Content))
                            </p>
                            <p>
                                <a href="/posts?feedUrl=@System.Net.WebUtility.UrlEncode(post.FeedUrl)" onclick="event.stopPropagation()">View all posts from this feed</a><br/>
                            </p>
                        </div>
                    }
                    else
                    {
                        <p>Loading...</p>
                    }
                </div>
            }
            <div class="row" style="height: 100px">
                &nbsp;
            </div>
            <div class="row">
                <div id="observerTarget">
                    RssApp
                </div>
            </div>
        </InfiniteScroll>
    </div>
}

<script type="text/javascript">
window.Observer = {
    observer: null,
    Initialize: function (component, observerTargetId) {
        this.observer = new IntersectionObserver(e => {
            // Check here
            if (e[0].isIntersecting) {
                component.invokeMethodAsync('OnIntersection');
            }
        },
        {
            root: null,
            rootMargin: '0px',
            threshold: [0]
        });

        let element = document.getElementById(observerTargetId);
        if (element == null) throw new Error("The observable target was not found");
        this.observer.observe(element);
    }
};
</script>

@code {
    public IEnumerable<string> userTags = new List<string>();

    [CascadingParameter(Name = "FeedClient")]
    public IFeedClient FeedClient { get; set; }

    [CascadingParameter(Name = "CurrentUser")]
    public RssUser User { get; set; }

    [CascadingParameter(Name = "ShowToolbar")]
    public bool ShowToolbar { get; set; } = true;

    [CascadingParameter(Name = "Page")]
    public int Page { get; set; } = 0;
    
    [CascadingParameter(Name = "Posts")]
    public ICollection<NewsFeedItem> Posts { get; set; } = new List<NewsFeedItem>();
    [Parameter]
    public EventCallback<int> OnPageChanged { get; set; }

    [Parameter]
    public EventCallback<(bool, bool, string)> OnRefreshTriggered { get; set; }

    public bool IsFilterUnread { get; set; } = false;
    public bool IsFilterSaved { get; set; } = false;
    private string filterTag = null;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (User == null)
        {
            var username = await this.GetUsernameAsync();
            if (username == null)
            {
                return;
            }
            this.User = await this.FeedClient.RegisterUserAsync(username);
            this.userTags = this.FeedClient.GetUserTags(User);
                var storedIsFilterUnread = await jsRuntime.InvokeAsync<string>("localStorage.getItem", "isFilterUnread");
                var storedIsFilterSaved = await jsRuntime.InvokeAsync<string>("localStorage.getItem", "isFilterSaved");
                var storedFilterTag = await jsRuntime.InvokeAsync<string>("localStorage.getItem", "filterTag");
                var storedPage = await jsRuntime.InvokeAsync<string>("localStorage.getItem", "currentPage");

                if (!bool.TryParse(storedIsFilterUnread, out bool isFilterUnread))
                {
                    this.IsFilterUnread = false;
                }
                else
                {
                    this.IsFilterUnread = isFilterUnread;
                }

                if (!bool.TryParse(storedIsFilterSaved, out bool isFilterSaved))
                {
                    this.IsFilterSaved = false;
                }
                else
                {
                    this.IsFilterSaved = isFilterSaved;
                }
                this.filterTag = storedFilterTag;
                if (int.TryParse(storedPage, out int page))
                {
                    this.Page = page;
                }

            this.StateHasChanged();
        }
    }

    private async Task SaveState()
    {
        await jsRuntime.InvokeVoidAsync("localStorage.setItem", "isFilterUnread", this.IsFilterUnread);
        await jsRuntime.InvokeVoidAsync("localStorage.setItem", "isFilterSaved", this.IsFilterSaved);
        await jsRuntime.InvokeVoidAsync("localStorage.setItem", "filterTag", this.filterTag);
        await jsRuntime.InvokeVoidAsync("localStorage.setItem", "currentPage", this.Page.ToString());
    }

    private bool ShouldPostBeHidden(NewsFeedItem post)
    {
        bool isFilteredByTag = this.filterTag != null && !post.FeedTags.Contains(this.filterTag);
        bool isFilteredByUnread = !post.IsBeingPreviewed && this.IsFilterUnread && post.IsRead;
        return isFilteredByTag || isFilteredByUnread;
    }

    private void MarkAsRead(NewsFeedItem item, bool? isRead = null)
    {
        bool val = isRead ?? !item.IsRead;
        item.IsRead = val;
        this.FeedClient.MarkAsRead(item, val);
        InvokeAsync(StateHasChanged);
    }

    private async Task ToggleUnreadFilterAsync()
    {
        this.IsFilterUnread = !this.IsFilterUnread;
        await SaveState();
        await this.OnRefreshTriggered.InvokeAsync((this.IsFilterUnread, this.IsFilterSaved, this.filterTag));
    }

    private async Task ToggleSavedFilterAsync()
    {
        this.IsFilterSaved = !this.IsFilterSaved;
        await SaveState();
        await this.OnRefreshTriggered.InvokeAsync((this.IsFilterUnread, this.IsFilterSaved, this.filterTag));
    }

    private async Task FilterForTag(string tag)
    {
        if (this.filterTag == tag)
        {
            this.filterTag = null;
        }
        else
        {
            this.filterTag = tag;
        }
        await SaveState();
        await this.OnRefreshTriggered.InvokeAsync((this.IsFilterUnread, this.IsFilterSaved, this.filterTag));
    }

    private void PreviewPost(NewsFeedItem post)
    {
        post.IsBeingPreviewed = !post.IsBeingPreviewed;
        InvokeAsync(this.StateHasChanged);
        MarkAsRead(post, true);
    }

    private async Task Next()
    {
        await this.OnPageChanged.InvokeAsync(this.Page);
        await SaveState();
        await InvokeAsync(this.StateHasChanged);
    }

    private string GetRootDomain(string url)
    {
        if (string.IsNullOrWhiteSpace(url))
        {
            return string.Empty;
        }

        return new Uri(url).Authority;
    }

    private string GetEffectiveHref(NewsFeedItem post)
    {
        if (post.IsPaywalled)
        {
            return "https://archive.is/" + post.Href;
        }

        return post.Href;
    }

    private async Task SavePost(NewsFeedItem post)
    {
        if (!post.IsSaved)
        {
            logger.LogInformation("Saving post {post}", post);
            await this.FeedClient.SavePostAsync(post);
            post.IsSaved = true;
        }
        else    
        {
            logger.LogInformation("Unsaving post {post}", post);
            await this.FeedClient.UnsavePostAsync(post);
            post.IsSaved = false;
        }

        await InvokeAsync(StateHasChanged);
    }
}
</AuthorizeView>