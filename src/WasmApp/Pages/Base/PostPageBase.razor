@using RssApp.Contracts
@inherits PageBase
@implements IDisposable
@inject ILogger<PostPageBase> logger
@inject IJSRuntime jsRuntime

@code {
    public List<NewsFeedItem> Items { get; set; } = new List<NewsFeedItem>();
    public int Page { get; set; } = 0;
    protected bool initialized = false;
    protected int loadedPage = -1;

    public void Dispose()
    {
        this.Items.Clear();
    }

    protected virtual async Task<List<NewsFeedItem>> GetPostsAsync()
    {
        // overriden
        throw new NotImplementedException();
    }

    protected async Task UpdatePage(int page)
    {
        if (!initialized)
        {
            return;
        }

        Page = page;

        await this.RefreshItems((this.feedClient.IsFilterUnread, this.feedClient.IsFilterSaved, this.feedClient.FilterTag));
    }

    protected async Task RefreshItems((bool isFilterUnread, bool isFilterSaved, string filterTag) filters)
    {
        if (filters.isFilterUnread != this.feedClient.IsFilterUnread
            || filters.isFilterSaved != this.feedClient.IsFilterSaved
            || filters.filterTag != this.feedClient.FilterTag)
        {
            Items = new List<NewsFeedItem>();
            Page = 0;
            this.loadedPage = -1;
            this.feedClient.IsFilterUnread = filters.isFilterUnread;
            this.feedClient.IsFilterSaved = filters.isFilterSaved;
            this.feedClient.FilterTag = filters.filterTag;
        }
        
        var newPageRes = await this.GetPostsAsync();
        Items.AddRange(newPageRes);
        Items = Items.Distinct().ToList();
        this.loadedPage = Page;
        
        this.StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender)
        {
            return;
        }

        if (!initialized)
        {
            try
            {
                // Try to restore last post
                //var lastPostHref = await jsRuntime.InvokeAsync<string>("rssApp.getLastPostId");
                @* var isUnread = await jsRuntime.InvokeAsync<bool>("rssApp.getIsFilterUnread");
                var isSaved = await jsRuntime.InvokeAsync<bool>("rssApp.getIsFilterSaved");
                var filterTag = await jsRuntime.InvokeAsync<string>("rssApp.getFilterTags");
                if (filterTag == "null")
                {
                    filterTag = null;
                }
                
                var lastSetStr = await jsRuntime.InvokeAsync<string>("rssApp.getLastSet");
                if (string.IsNullOrEmpty(lastSetStr))
                {
                    return;
                }

                var lastSetDate = DateTime.Parse(lastSetStr, null, System.Globalization.DateTimeStyles.AdjustToUniversal);
                if (lastSetDate < DateTime.UtcNow - TimeSpan.FromHours(1))
                {
                    return;
                }

                this.feedClient.IsFilterUnread = isUnread;
                this.feedClient.IsFilterSaved = isSaved;
                this.feedClient.FilterTag = filterTag;

                await jsRuntime.InvokeVoidAsync("rssApp.clearData"); *@
            }
            finally 
            {
                Items = await this.GetPostsAsync();
                this.initialized = true;
                this.StateHasChanged();
            }
        }
    }
}
