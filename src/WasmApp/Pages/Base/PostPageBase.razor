@using RssApp.Contracts
@inherits PageBase
@implements IDisposable
@inject ILogger<PostPageBase> logger
@inject IJSRuntime jsRuntime

@code {
    private bool _isRefreshing;
    public List<NewsFeedItem> Items { get; set; } = new List<NewsFeedItem>();
    public int Page { get; set; } = 0;
    protected bool initialized = false;

    public void Dispose()
    {
        this.Items.Clear();
    }

    protected virtual Task<List<NewsFeedItem>> GetPostsAsync()
    {
        // overriden
        throw new NotImplementedException();
    }

    protected async Task UpdatePage(int page)
    {
        if (!initialized || _isRefreshing)
        {
            return;
        }

        Page = page;
        await this.RefreshItems((this.feedClient.IsFilterUnread, this.feedClient.IsFilterSaved, this.feedClient.FilterTag));
    }

    protected async Task RefreshItems((bool isFilterUnread, bool isFilterSaved, string filterTag) filters)
    {
        // Being invoked by async javascript, this method can be called multiple times before the first call is complete.
        // A race condition can happen where either the 1st or 2nd page are overwritten, causing an incomplete response.
        // To avoid this race condition, we use _isRefreshing to ensure that only one call is processed at a time.
        // There is no multi-threading in this context (currently not enabled), so thread synchronization is not needed.
        // We just need to exit early for overlapping calls if they are made while refresh is in progress.

        if (_isRefreshing)
        {
            return;
        }

        try
        {
            _isRefreshing = true;
            
            if (UpdateFilters(filters))
            {
                Items.Clear();
                Page = 0;
            }
            
            var newPageRes = await this.GetPostsAsync();
            Items.AddRange(newPageRes);
            
            this.StateHasChanged();
        }
        finally
        {
            _isRefreshing = false;
        }
    }

    private bool UpdateFilters((bool isFilterUnread, bool isFilterSaved, string filterTag) filters)
    {
        bool hasChanged = filters.isFilterUnread != this.feedClient.IsFilterUnread
            || filters.isFilterSaved != this.feedClient.IsFilterSaved
            || filters.filterTag != this.feedClient.FilterTag;

        if (hasChanged)
        {
            this.feedClient.IsFilterUnread = filters.isFilterUnread;
            this.feedClient.IsFilterSaved = filters.isFilterSaved;
            this.feedClient.FilterTag = filters.filterTag;
        }

        return hasChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            this.initialized = true;
            if (this.Items == null || !this.Items.Any())
            {
                await this.RefreshItems((this.feedClient.IsFilterUnread, this.feedClient.IsFilterSaved, this.feedClient.FilterTag));
            }
        }
    }
}
