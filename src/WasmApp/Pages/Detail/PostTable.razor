@inherits PageBase
@implements IDisposable
@rendermode InteractiveWebAssembly
@attribute [StreamRendering]
@attribute [Authorize]
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Sve.Blazor.InfiniteScroll.Components
@using WasmApp.Pages.Detail

@inject ILogger<Posts> logger
@inject IJSRuntime jsRuntime
@inject NavigationManager NavigationManager

<SectionContent SectionName="toolbar">
    <Toolbar
        filterTag="@filterTag"
        IsFilterUnread="@IsFilterUnread"
        IsFilterSaved="@IsFilterSaved"
        userTags="@userTags"
        ToggleUnreadFilterAsync="@ToggleUnreadFilterAsync"
        ToggleSavedFilterAsync="@ToggleSavedFilterAsync"
        FilterForTag="@FilterForTag"
        Posts="@Posts"
    />
</SectionContent>


<div id="post-table" class="table">
    @if (isLoading)
    {
        <div class="d-flex flex-column justify-content-center align-items-center" style="min-height: 60vh;">
            @if (_hasTimedOut)
            {
                <p class="text-muted mb-3">Loading is taking longer than expected.</p>
                <button class="btn btn-primary" @onclick="Retry">Try Again</button>
            }
            else
            {
                <div class="spinner mb-3"></div>
                <p class="text-muted">
                @if (_showColdStartText)
                {
                    <span>Waiting for backend cold start. This might take a few seconds...</span>
                }
                else
                {
                    <span>&nbsp;</span>
                }
                </p>
            }
        </div>
    }
    else if (Posts == null || Posts.Count == 0)
    {
        <div class="no-posts-message">
            <p>No posts found.</p>
        </div>
    }
    else
    {
        <InfiniteScroll ObserverTargetId="observerTarget" ObservableTargetReached="(e) => Next()">
            @foreach (var post in Posts)
            {
                <PostDetail 
                    Post="@post"
                    FilterTag="@this.filterTag"
                    IsFilterUnread="@this.IsFilterUnread"/>
            }

            <div class="row">
                <div id="observerTarget">
                    RssApp
                </div>
            </div>
            
        </InfiniteScroll>
    }
</div>

@code {
    [CascadingParameter(Name = "Posts")]
    public List<NewsFeedItem> Posts { get; set; }
    
    [CascadingParameter(Name = "Page")]
    private int Page { get; set; }

    [Parameter]
    public EventCallback<int> OnPageChanged { get; set; }

    [Parameter]
    public EventCallback<(bool, bool, string)> OnRefreshTriggered { get; set; }

    [Parameter]
    public IFeedClient FeedClient { get; set; }

    public IEnumerable<string> userTags = null;
    public bool IsFilterUnread => FeedClient.IsFilterUnread;
    public bool IsFilterSaved => FeedClient.IsFilterSaved;
    private string filterTag => FeedClient.FilterTag;

    private const int MaxPostsToKeep = 100;  // Adjust this number based on your needs
    private const int LoadingTimeoutMs = 30000;
    private const int ColdStartTextDelayMs = 2000;
    private bool isLoading = true;
    private bool _hasTimedOut = false;
    private bool _showColdStartText = false;
    private System.Timers.Timer _timeoutTimer;
    private System.Timers.Timer _coldStartTextTimer;

    public void Dispose()
    {
        _timeoutTimer?.Stop();
        _timeoutTimer?.Dispose();
        _coldStartTextTimer?.Stop();
        _coldStartTextTimer?.Dispose();
        FeedClient.Dispose();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            StartTimeoutTimer();
            StartColdStartTextTimer();
            this.userTags = await FeedClient.GetUserTagsAsync(CurrentUser);
            StateHasChanged();
        }
    }
    private void StartColdStartTextTimer()
    {
        _showColdStartText = false;
        _coldStartTextTimer?.Stop();
        _coldStartTextTimer?.Dispose();
        _coldStartTextTimer = new System.Timers.Timer(ColdStartTextDelayMs);
        _coldStartTextTimer.AutoReset = false;
        _coldStartTextTimer.Elapsed += (s, e) =>
        {
            if (isLoading)
            {
                _showColdStartText = true;
                InvokeAsync(StateHasChanged);
            }
        };
        _coldStartTextTimer.Start();
    }

    private void StartTimeoutTimer()
    {
        _hasTimedOut = false;
        _timeoutTimer?.Stop();
        _timeoutTimer?.Dispose();
        _timeoutTimer = new System.Timers.Timer(LoadingTimeoutMs);
        _timeoutTimer.AutoReset = false;
        _timeoutTimer.Elapsed += (s, e) =>
        {
            if (isLoading)
            {
                _hasTimedOut = true;
                InvokeAsync(StateHasChanged);
            }
        };
        _timeoutTimer.Start();
    }

    private void StopTimeoutTimer()
    {
        _timeoutTimer?.Stop();
        _hasTimedOut = false;
        _coldStartTextTimer?.Stop();
        _showColdStartText = false;
    }

    private void Retry()
    {
        NavigationManager.NavigateTo(NavigationManager.Uri, forceLoad: true);
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // When Posts parameter changes, we're done loading
        if (Posts != null && Posts.Any())
        {
            isLoading = false;
            StopTimeoutTimer();
        }
    }

    private async Task ToggleUnreadFilterAsync()
    {
        isLoading = true;
        await this.OnRefreshTriggered.InvokeAsync((!this.IsFilterUnread, this.IsFilterSaved, this.filterTag));
    }

    private async Task ToggleSavedFilterAsync()
    {
        isLoading = true;
        await this.OnRefreshTriggered.InvokeAsync((this.IsFilterUnread, !this.IsFilterSaved, this.filterTag));
    }

    private async Task FilterForTag(string tag)
    {
        isLoading = true;
        if (this.filterTag == tag)
        {
            tag = null;
        }
        await this.OnRefreshTriggered.InvokeAsync((this.IsFilterUnread, this.IsFilterSaved, tag));
    }

    private async Task Next()
    {
        isLoading = true;
        await this.OnPageChanged.InvokeAsync(this.Page + 1);
        isLoading = false;
        await InvokeAsync(this.StateHasChanged);
    }
}