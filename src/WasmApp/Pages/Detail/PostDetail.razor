@using System.Threading.Tasks
@inherits PageBase

@rendermode InteractiveWebAssembly
@attribute [StreamRendering]
@* @attribute [Authorize] *@
@inject IJSRuntime jsRuntime
@inject NavigationManager navigationManager

@if (Post != null)
{
<div class="row @(Post.IsRead ? "post-read" : "post-unread")" @onclick="async () => await HandleClick(Post)" hidden=@(ShouldPostBeHidden(Post))>
    <div class="col thumbnail">
        @{
            var thumbnailUrl = Post.GetThumbnailUrl();
            if (!String.IsNullOrWhiteSpace(thumbnailUrl))
            {
                <img src="@thumbnailUrl" alt="Thumbnail" class="thumbnail" />
            }
            else
            {
                <img src="/placeholder.jpg" alt="Placeholder" class="thumbnail" />
            }
        }
    </div>
    <div class="col">
        <p class="post-title">
            <a tooltip="@Post.ParsedDate?.ToString("f")" href="@Post.Href" @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="async () => { await MarkAsReadAsync(Post, true); navigationManager.NavigateTo(Post.Href); }">@Post.Title</a><br/>
            @if (!String.IsNullOrWhiteSpace(Post.CommentsHref))
            {
                <a href="@Post.CommentsHref">[comments]</a>
            }
            <button class="link" @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="async () => await MarkAsReadAsync(Post, !Post.IsRead)">[mark @(!Post.IsRead ? "read" : "unread")]</button>
            <button class="link" @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="async () => await SavePost(Post)">[@(!Post.IsSaved ? "save" : "unsave")]</button>
            @Post.Href.GetRootDomain()<br/>
            @(Post.FeedTags.Any() ? $"[{string.Join(",", Post.FeedTags)}]" : "")
        </p>
    </div>
</div>
<div class="postContent" hidden=@(!Post.IsBeingPreviewed)>
    @if (Post != null)
    {
        <div class="">
            <p>
                Published on @Post.ParsedDate?.ToString("f")
            </p>
            <p>
                <button class="link" @onclick:stopPropagation="true" @onclick:preventDefault="true" @onclick="() => OnSpeakTextClicked(Post)">[speak this text]</button>
            </p>
            <p>
                @if (Post?.GetThumbnailUrl() != null)
                {
                    if (Post.Content?.TrimStart().IndexOf(Post.GetThumbnailUrl()) < 0)
                    {
                        <img src="@Post.GetThumbnailUrl()" alt="Thumbnail" class="thumbnail" />
                    }
                }
            </p>
            <p>
                @((MarkupString)HtmlSanitizer.Sanitize(Post.Content))
            </p>
            <p>
                <a href="@Post.Href" rel="noopener noreferrer">View full post</a>
            </p>
            <p>
                <a href="/posts?href=@System.Net.WebUtility.UrlEncode(Post.FeedUrl)" onclick="event.stopPropagation()">View all posts from this feed</a><br/>
            </p>
            <p>
                <button class="btn-link" @onclick="async () => await HandleClick(Post)">Collapse</button>
            </p>
        </div>
    }
    else
    {
        <p>Loading...</p>
    }
</div>
}

@code {
    [Parameter]
    public NewsFeedItem Post { get; set; }

    [Parameter]
    public string FilterTag { get; set; }

    [Parameter]
    public bool IsFilterUnread { get; set; }

    [Parameter]
    public EventCallback OnPostClicked { get; set; }

    private async Task OnSpeakTextClicked(NewsFeedItem post)
    {
        if (post?.Content != null)
        {
            await jsRuntime.InvokeVoidAsync("speakThisText", post.Content);
        }
    }

    private bool ShouldPostBeHidden(NewsFeedItem post)
    {
        bool isFilteredByTag = !string.IsNullOrWhiteSpace(this.FilterTag) && !post.FeedTags.Contains(this.FilterTag);
        bool isFilteredByUnread = !post.IsBeingPreviewed && this.IsFilterUnread && post.IsRead;
        return isFilteredByTag || isFilteredByUnread;
    }

    private async Task MarkAsReadAsync(NewsFeedItem item, bool isRead)
    {
        if (isRead && !item.IsRead)
        {
            await this.feedClient.MarkAsReadAsync(item, true);
            item.IsRead = true;
        }
        else if (!isRead && item.IsRead)
        {
            await this.feedClient.MarkAsReadAsync(item, false);
            item.IsRead = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task PreviewPostAsync(NewsFeedItem post)
    {
        if (post.Content == null)
        {
            post.Content = await this.feedClient.GetItemContentAsync(post);
            this.StateHasChanged();
        }

        post.IsBeingPreviewed = !post.IsBeingPreviewed;
        await InvokeAsync(StateHasChanged);
    }

    private async Task SavePost(NewsFeedItem post)
    {
        if (!post.IsSaved)
        {
            await this.feedClient.SavePostAsync(post);
            post.IsSaved = true;
        }
        else    
        {
            await this.feedClient.UnsavePostAsync(post);
            post.IsSaved = false;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleClick(NewsFeedItem post, bool preview = true)
    {
        if (preview)
        {
            await PreviewPostAsync(post);
            await MarkAsReadAsync(post, true);
        }
    }
}